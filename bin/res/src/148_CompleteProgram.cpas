// 148_CompleteProgram.cpas
// BNF Rule: All rules integration - Complete CPascal Program
// This program demonstrates comprehensive usage of CPascal language features
{$DEFINE DEBUG}
{$LINK "kernel32.lib"}
{$APPTYPE "console"}
program CompleteProgram;

// External functions
function printf(format: PChar, ...): Int32; cdecl; external "msvcrt.dll";
function malloc(size: Int32): Pointer; cdecl; external "msvcrt.dll";
procedure free(ptr: Pointer); cdecl; external "msvcrt.dll";

// Constants section
const
  MAX_ITEMS = 100;
  PI = 3.14159265359;
  APP_NAME = 'CPascal Complete Demo';
  VERSION = "1.0.0";

// Type definitions
type
  TStatus = (stIdle, stRunning, stComplete, stError);
  TRange = 1..100;
  PInteger = ^Int32;
  TIntArray = array[0..MAX_ITEMS-1] of Int32;
  
  TPoint = record
    x, y: Int32;
    color: UInt32;
  end;
  
  TUnion = union
    asInt: Int32;
    asBytes: array[0..3] of UInt8;
  end;
  
  TMathFunc = function(x: Double): Double; cdecl;

// Variables section
var
  LStatus: TStatus;
  LCounter: Int32;
  LPoints: array[0..9] of TPoint;
  LData: TIntArray;
  LValue: TUnion;

// Label section
label
  MainLoop, ExitPoint;

// Forward declaration
function CalculateDistance(const APoint1, APoint2: TPoint): Double; forward;

// Inline function
function Square(x: Int32): Int32; inline;
begin
  result := x * x;
end;

// Varargs function
function LogFormatted(level: Int32, format: PChar, ...): Int32; cdecl;
begin
  printf('[Level %d] ', level);
  printf(format);
  printf('\n');
  result := 0;
end;

// Main calculation function
function CalculateDistance(const APoint1, APoint2: TPoint): Double;
var
  LDeltaX, LDeltaY: Int32;
  LDistanceSquared: Int32;
begin
  LDeltaX := APoint1.x - APoint2.x;
  LDeltaY := APoint1.y - APoint2.y;
  LDistanceSquared := Square(LDeltaX) + Square(LDeltaY);
  
  // Simplified distance calculation (no sqrt available)
  result := LDistanceSquared;
end;

// Procedure with complex statements
procedure ProcessData();
var
  LIndex: Int32;
  LSum: Int32;
  LPtr: PInteger;
begin
  LogFormatted(1, 'Processing data array');
  
  // Initialize data
  LSum := 0;
  for LIndex := 0 to 9 do
  begin
    LData[LIndex] := LIndex * LIndex;
    LSum += LData[LIndex];
  end;
  
  printf('Sum of squares 0-9: %d\n', LSum);
  
  // Demonstrate pointer usage
  LPtr := @LData[5];
  printf('Value at index 5: %d\n', LPtr^);
  
  // Union demonstration
  LValue.asInt := $12345678;
  printf('Union as int: %d, as bytes: %02X %02X %02X %02X\n', 
         LValue.asInt, LValue.asBytes[0], LValue.asBytes[1], 
         LValue.asBytes[2], LValue.asBytes[3]);
end;

// Procedure with control structures
procedure DemonstrateControlFlow();
var
  LIndex: Int32;
  LChoice: Int32;
begin
  LogFormatted(1, 'Demonstrating control flow');
  
  // If statement with complex expression
  if (LCounter > 0) and (LCounter < MAX_ITEMS) then
    printf('Counter is in valid range: %d\n', LCounter)
  else
    printf('Counter out of range: %d\n', LCounter);
  
  // Case statement
  LChoice := LCounter mod 4;
  case LChoice of
    0: printf('Choice is zero\n');
    1, 2: printf('Choice is one or two\n');
    3: printf('Choice is three\n');
  else
    printf('Unexpected choice\n');
  end;
  
  // While loop with break/continue
  LIndex := 0;
  while LIndex < 10 do
  begin
    if LIndex = 3 then
    begin
      Inc(LIndex);
      continue;
    end;
    
    if LIndex = 7 then
      break;
      
    printf('Index: %d\n', LIndex);
    Inc(LIndex);
  end;
  
  // Repeat-until loop
  LIndex := 0;
  repeat
    printf('Repeat index: %d\n', LIndex);
    Inc(LIndex);
  until LIndex >= 3;
end;

// Assembly demonstration
procedure DemonstrateAssembly();
begin
  {$IFDEF DEBUG}
  LogFormatted(1, 'Assembly operations would go here');
  // Note: Actual inline assembly syntax would be:
  // asm
  //   "mov %0, %%eax" : "=r"(result) : "r"(input) : "eax";
  // end;
  {$ENDIF}
end;

// Main program logic
begin
  printf('=== %s v%s ===\n', APP_NAME, VERSION);
  printf('Complete CPascal Language Demonstration\n\n');
  
  // Initialize
  LStatus := stRunning;
  LCounter := 42;
  
  // Initialize points
  LPoints[0].x := 10;
  LPoints[0].y := 20;
  LPoints[0].color := $FF0000;
  
  LPoints[1].x := 30;
  LPoints[1].y := 40;
  LPoints[1].color := $00FF00;
  
  printf('Point 1: (%d, %d) Color: $%06X\n', 
         LPoints[0].x, LPoints[0].y, LPoints[0].color);
  printf('Point 2: (%d, %d) Color: $%06X\n', 
         LPoints[1].x, LPoints[1].y, LPoints[1].color);
  
  // Calculate distance
  var LDistance: Double := CalculateDistance(LPoints[0], LPoints[1]);
  printf('Distance squared: %.2f\n\n', LDistance);
  
MainLoop:
  // Process data
  ProcessData();
  printf('\n');
  
  // Demonstrate control flow
  DemonstrateControlFlow();
  printf('\n');
  
  // Assembly demonstration
  DemonstrateAssembly();
  printf('\n');
  
  // Conditional compilation demonstration
  {$IFDEF DEBUG}
  printf('DEBUG: This is a debug build\n');
  LogFormatted(2, 'Debug information available');
  {$ELSE}
  printf('RELEASE: This is a release build\n');
  {$ENDIF}
  
  {$IFNDEF TESTING}
  printf('Production mode active\n');
  {$ENDIF}
  
  // Status update
  LStatus := stComplete;
  printf('\nProgram Status: ');
  case LStatus of
    stIdle: printf('Idle');
    stRunning: printf('Running');
    stComplete: printf('Complete');
    stError: printf('Error');
  end;
  printf('\n');
  
  // Goto demonstration (rarely used)
  if LCounter = 42 then
    goto ExitPoint;
    
  printf('This line should be skipped\n');
  
ExitPoint:
  printf('\n=== Program Completed Successfully ===\n');
  printf('Demonstrated Features:\n');
  printf('- Program structure with imports/exports\n');
  printf('- Constants, types, variables, functions\n');
  printf('- Records, unions, arrays, pointers\n');
  printf('- Control flow: if, case, while, for, repeat\n');
  printf('- Inline and varargs functions\n');
  printf('- External function declarations\n');
  printf('- Conditional compilation\n');
  printf('- Expression evaluation and operators\n');
  printf('- Labels and goto statements\n');
  printf('- Complete BNF grammar coverage\n');
end.
